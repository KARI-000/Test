<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Ultimate Audio Studio Visualizer - Final Pro</title>
    <style>
        :root { --bg: #020202; --accent: #00f2ff; --panel: #0f0f0f; --border: #222; }
        body { background: var(--bg); color: #eee; font-family: 'Consolas', monospace; margin: 0; overflow: hidden; display: flex; flex-direction: column; height: 100vh; }
        
        #toolbar {
            background: var(--panel); padding: 12px 20px; display: flex; gap: 20px; 
            align-items: center; border-bottom: 1px solid var(--border); z-index: 100; flex-wrap: wrap;
        }
        .tool-group { display: flex; flex-direction: column; gap: 5px; }
        .tool-group label { font-size: 9px; color: #666; font-weight: bold; text-transform: uppercase; }
        
        select, button, input[type="range"], input[type="file"] {
            background: #000; border: 1px solid #333; color: #fff; padding: 6px; font-size: 11px; border-radius: 2px;
        }
        button { cursor: pointer; transition: 0.2s; font-weight: bold; min-width: 60px; }
        button:hover:not(:disabled) { border-color: var(--accent); background: #111; }
        button.active { background: var(--accent); color: #000; border-color: var(--accent); }
        button:disabled { opacity: 0.2; cursor: not-allowed; }

        #viewport { flex-grow: 1; display: flex; background: #000; width: 100vw; height: calc(100vh - 85px); }
        .module { position: relative; flex: 1; border-right: 1px solid #111; display: none; height: 100%; overflow: hidden; }
        .module.active { display: block; }
        .module.square { flex: 0 0 auto; width: 35vh; min-width: 300px; }
        
        canvas { width: 100%; height: 100%; image-rendering: pixelated; }
        .tag { position: absolute; top: 8px; left: 10px; font-size: 9px; color: #444; pointer-events: none; z-index: 5; }
        #status { font-size: 11px; color: var(--accent); min-width: 200px; }
    </style>
</head>
<body>

<div id="toolbar">
    <div class="tool-group">
        <label>1. Audio File</label>
        <input type="file" id="audioInput" accept="audio/wav,audio/mp3,audio/flac">
    </div>

    <div class="tool-group">
        <label>2. Sample Rate</label>
        <select id="srSelect">
            <option value="44100">44.1 kHz</option>
            <option value="48000" selected>48.0 kHz</option>
            <option value="96000">96.0 kHz</option>
        </select>
    </div>

    <div class="tool-group">
        <label>3. Visual Speed (px/f)</label>
        <input type="range" id="speedRange" min="1" max="15" value="5">
    </div>

    <div class="tool-group">
        <label>4. Color Palette</label>
        <select id="colorSelect">
            <option value="magma">MAGMA (MiniMeters)</option>
            <option value="cyber">CYBER (Neon)</option>
            <option value="acid">ACID (High Con)</option>
            <option value="ice">ICE (Blue)</option>
            <option value="gold">GOLD (Luxury)</option>
            <option value="blood">BLOOD (Dark)</option>
        </select>
    </div>

    <div class="tool-group">
        <label>5. Layout</label>
        <div style="display:flex; gap:4px;">
            <button id="btnSpec" class="active">SPEC</button>
            <button id="btnWave">WAVE</button>
            <button id="btnStereo">STEREO</button>
        </div>
    </div>

    <div class="tool-group">
        <label>6. Action</label>
        <div style="display:flex; gap:4px;">
            <button id="playBtn" disabled>START</button>
            <button id="stopBtn" disabled>STOP</button>
        </div>
    </div>

    <div id="status">WAITING FOR FILE...</div>
</div>

<div id="viewport">
    <div id="modSpec" class="module active">
        <div class="tag">SPECTROGRAM (LOGARITHMIC)</div>
        <canvas id="canvasSpec"></canvas>
    </div>
    <div id="modWave" class="module">
        <div class="tag">OSCILLOSCOPE (MONO)</div>
        <canvas id="canvasWave"></canvas>
    </div>
    <div id="modStereo" class="module square">
        <div class="tag">STEREO PHASE (XY)</div>
        <canvas id="canvasStereo"></canvas>
    </div>
</div>

<script>
    const FFT_SIZE = 16384;
    let audioCtx, source, analyserMono, analyserL, analyserR, animationId;
    let audioBuffer = null;

    const statusEl = document.getElementById('status');
    const inputEl = document.getElementById('audioInput');
    const playBtn = document.getElementById('playBtn');
    const speedRange = document.getElementById('speedRange');

    // --- Color Presets Definition ---
    const palettes = {
        magma: (v) => [v * 255, Math.pow(v, 3) * 180, Math.pow(v, 6) * 255],
        cyber: (v) => [v * 255, Math.pow(v, 2) * 80, 255 - v * 150],
        acid: (v) => [Math.pow(v, 4) * 200, v * 255, 0],
        ice: (v) => [Math.pow(v, 3) * 150, Math.pow(v, 1.2) * 200, v * 255],
        gold: (v) => [v * 255, v * 210, Math.pow(v, 2) * 40],
        blood: (v) => [v * 255, 0, Math.pow(v, 4) * 50]
    };

    function getRGB(v, preset) {
        const [r, g, b] = palettes[preset](Math.max(0, Math.min(1, v)));
        const glow = v > 0.9 ? (v - 0.9) * 10 * 255 : 0; // 高輝度部の白飛び発光
        return `rgb(${Math.min(255, r + glow)},${Math.min(255, g + glow)},${Math.min(255, b + glow)})`;
    }

    // --- Layout Management ---
    const modules = {
        Spec: { btn: document.getElementById('btnSpec'), el: document.getElementById('modSpec'), ctx: document.getElementById('canvasSpec').getContext('2d', {alpha:false}) },
        Wave: { btn: document.getElementById('btnWave'), el: document.getElementById('modWave'), ctx: document.getElementById('canvasWave').getContext('2d') },
        Stereo: { btn: document.getElementById('btnStereo'), el: document.getElementById('modStereo'), ctx: document.getElementById('canvasStereo').getContext('2d') }
    };

    Object.keys(modules).forEach(key => {
        modules[key].btn.onclick = () => {
            modules[key].btn.classList.toggle('active');
            modules[key].el.classList.toggle('active');
            resize();
        };
    });

    function resize() {
        Object.keys(modules).forEach(key => {
            const c = modules[key].ctx.canvas;
            c.width = c.clientWidth * window.devicePixelRatio;
            c.height = c.clientHeight * window.devicePixelRatio;
            if(key === 'Spec') { // スペクトログラムの背景を黒で初期化
                modules[key].ctx.fillStyle = "#000";
                modules[key].ctx.fillRect(0,0,c.width,c.height);
            }
        });
    }
    window.addEventListener('resize', resize);

    // --- Robust File Loading ---
    inputEl.onchange = async (e) => {
        const file = e.target.files[0];
        if (!file) return;

        statusEl.innerText = "LOADING...";
        playBtn.disabled = true;

        try {
            const arrayBuffer = await file.arrayBuffer();
            // デコード用に一時的なContextを作成（サンプリングレート不一致を防ぐ）
            const tempCtx = new (window.AudioContext || window.webkitAudioContext)();
            statusEl.innerText = "DECODING WAV...";
            audioBuffer = await tempCtx.decodeAudioData(arrayBuffer);
            tempCtx.close();

            statusEl.innerText = `READY: ${file.name.slice(0,20)}`;
            playBtn.disabled = false;
            resize();
        } catch (err) {
            statusEl.innerText = "ERROR: LOAD FAILED";
            console.error(err);
        }
    };

    // --- Audio & Visualization Engine ---
    async function start() {
        if (!audioBuffer) return;
        if (audioCtx) await audioCtx.close();

        const sr = parseInt(document.getElementById('srSelect').value);
        audioCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: sr });

        source = audioCtx.createBufferSource();
        source.buffer = audioBuffer;

        analyserMono = audioCtx.createAnalyser();
        analyserMono.fftSize = FFT_SIZE;
        analyserMono.smoothingTimeConstant = 0.05;

        const splitter = audioCtx.createChannelSplitter(2);
        analyserL = audioCtx.createAnalyser();
        analyserR = audioCtx.createAnalyser();
        analyserL.fftSize = analyserR.fftSize = 2048;

        source.connect(analyserMono);
        source.connect(splitter);
        splitter.connect(analyserL, 0);
        splitter.connect(analyserR, 1);
        source.connect(audioCtx.destination);

        source.start(0);
        document.getElementById('stopBtn').disabled = false;
        statusEl.innerText = "ENGINE ACTIVE";
        draw();
    }

    function draw() {
        animationId = requestAnimationFrame(draw);
        const preset = document.getElementById('colorSelect').value;

        // 1. Spectrogram Rendering
        if (modules.Spec.el.classList.contains('active')) {
            const ctx = modules.Spec.ctx;
            const data = new Uint8Array(analyserMono.frequencyBinCount);
            analyserMono.getByteFrequencyData(data);
            const w = ctx.canvas.width, h = ctx.canvas.height;
            const speed = parseInt(speedRange.value);

            // シフト描画
            ctx.drawImage(ctx.canvas, speed, 0, w - speed, h, 0, 0, w - speed, h);
            ctx.fillStyle = "#000"; ctx.fillRect(w - speed, 0, speed, h);

            // 対数計算
            const logMin = Math.log10(20), logMax = Math.log10(20000);
            const res = 700; // 垂直解像度
            const barH = h / res;

            for (let i = 0; i < res; i++) {
                const p = i / res;
                const f = Math.pow(10, logMin + p * (logMax - logMin));
                const b = Math.floor(f / (audioCtx.sampleRate / FFT_SIZE));
                if (data[b] > 5) {
                    ctx.fillStyle = getRGB(data[b] / 255, preset);
                    ctx.fillRect(w - speed, h - (p * h), speed, barH + 1);
                }
            }
        }

        // 2. Waveform Rendering
        if (modules.Wave.el.classList.contains('active')) {
            const ctx = modules.Wave.ctx;
            const data = new Uint8Array(analyserL.fftSize);
            analyserL.getByteTimeDomainData(data);
            ctx.fillStyle = "rgba(0,0,0,0.3)"; ctx.fillRect(0,0,ctx.canvas.width, ctx.canvas.height);
            ctx.beginPath(); ctx.strokeStyle = getRGB(0.8, preset); ctx.lineWidth = 2;
            const step = ctx.canvas.width / data.length;
            for(let i=0; i<data.length; i++) {
                const x = i * step;
                const y = (data[i]/128 - 1) * ctx.canvas.height * 0.4 + ctx.canvas.height/2;
                if(i===0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
            }
            ctx.stroke();
        }

        // 3. Stereo Phase Rendering
        if (modules.Stereo.el.classList.contains('active')) {
            const ctx = modules.Stereo.ctx;
            const dL = new Uint8Array(analyserL.fftSize);
            const dR = new Uint8Array(analyserR.fftSize);
            analyserL.getByteTimeDomainData(dL);
            analyserR.getByteTimeDomainData(dR);
            ctx.fillStyle = "rgba(0,0,0,0.15)"; ctx.fillRect(0,0,ctx.canvas.width, ctx.canvas.height);
            ctx.beginPath(); ctx.strokeStyle = getRGB(0.9, preset); ctx.lineWidth = 1;
            const center = ctx.canvas.width/2;
            for(let i=0; i<dL.length; i+=2) {
                const l = (dL[i]/128 - 1), r = (dR[i]/128 - 1);
                const x = (l - r) * center * 0.75 + center;
                const y = (l + r) * center * 0.75 + center;
                if(i===0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
            }
            ctx.stroke();
        }
    }

    function stop() {
        if (source) try { source.stop(); } catch(e){}
        if (audioCtx) audioCtx.close();
        cancelAnimationFrame(animationId);
        statusEl.innerText = "HALTED";
    }

    playBtn.onclick = start;
    document.getElementById('stopBtn').onclick = stop;
</script>
</body>
</html>
