<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>MiniMeters Pro - Definitive Edition</title>
    <style>
        :root { --bg: #050505; --accent: #00f2ff; --panel: #0e0e0e; --border: #222; }
        body { background: var(--bg); color: #fff; font-family: 'Consolas', 'Courier New', monospace; margin: 0; overflow: hidden; display: flex; flex-direction: column; height: 100vh; }
        
        /* ツールバー */
        #toolbar {
            background: var(--panel); padding: 15px 25px; display: flex; gap: 20px; 
            align-items: center; border-bottom: 2px solid var(--border);
        }
        .tool-group { display: flex; flex-direction: column; gap: 6px; }
        .tool-group label { font-size: 10px; color: #666; font-weight: bold; text-transform: uppercase; letter-spacing: 1px; }
        
        input[type="file"], select, button, input[type="range"] {
            background: #000; border: 1px solid #333; color: #fff; padding: 7px 10px;
            font-size: 11px; border-radius: 2px; outline: none;
        }
        button { cursor: pointer; font-weight: 800; min-width: 80px; transition: 0.1s; border: 1px solid #444; }
        button:hover:not(:disabled) { border-color: var(--accent); background: #1a1a1a; }
        button.active { background: var(--accent); color: #000; border-color: var(--accent); }
        button#recBtn { color: #ff3366; border-color: #511; }
        button#recBtn.recording { background: #ff3366; color: #fff; animation: blink 0.8s infinite; }
        button:disabled { opacity: 0.15; cursor: not-allowed; }

        @keyframes blink { 50% { opacity: 0.3; } }

        /* ビューポート */
        #viewport { flex-grow: 1; display: flex; background: #000; width: 100vw; height: calc(100vh - 90px); }
        .module { position: relative; flex: 1; border-right: 1px solid #111; display: none; height: 100%; }
        .module.active { display: block; }
        .module.square { flex: 0 0 auto; width: 35vh; min-width: 320px; }
        
        canvas { width: 100%; height: 100%; image-rendering: pixelated; background: #000; }
        .tag { position: absolute; top: 10px; left: 12px; font-size: 10px; color: #555; pointer-events: none; z-index: 10; font-weight: bold; }
        
        #status-bar { font-size: 11px; color: var(--accent); min-width: 300px; background: #000; padding: 8px 15px; border: 1px solid #222; border-left: 4px solid var(--accent); }
    </style>
</head>
<body>

<div id="toolbar">
    <div class="tool-group">
        <label>1. Audio Source</label>
        <input type="file" id="audioInput" accept=".wav,.mp3,.flac,.aac">
    </div>

    <div class="tool-group">
        <label>2. Scroll Speed</label>
        <input type="range" id="speedRange" min="1" max="25" value="6">
    </div>

    <div class="tool-group">
        <label>3. Color Preset</label>
        <select id="colorSelect">
            <option value="magma">MAGMA (Standard)</option>
            <option value="cyber">CYBERPUNK (Neon)</option>
            <option value="acid">ACID (Toxic)</option>
            <option value="ice">FROZEN (Polar)</option>
            <option value="blood">BLOOD (Noir)</option>
        </select>
    </div>

    <div class="tool-group">
        <label>4. Toggle</label>
        <div style="display:flex; gap:5px;">
            <button id="btnSpec" class="active">SPECTRO</button>
            <button id="btnWave">WAVE</button>
            <button id="btnStereo">STEREO</button>
        </div>
    </div>

    <div class="tool-group">
        <label>5. Master</label>
        <div style="display:flex; gap:5px;">
            <button id="playBtn" disabled>PLAY</button>
            <button id="recBtn" disabled>REC .MOV</button>
            <button id="stopBtn" disabled>STOP</button>
        </div>
    </div>

    <div id="status-bar">SYSTEM IDLE // NO FILE LOADED</div>
</div>

<div id="viewport">
    <div id="modSpec" class="module active"><div class="tag">SPECTROGRAM // LOGARITHMIC</div><canvas id="canvasSpec"></canvas></div>
    <div id="modWave" class="module"><div class="tag">OSCILLOSCOPE // L-CH</div><canvas id="canvasWave"></canvas></div>
    <div id="modStereo" class="module square"><div class="tag">PHASE CORRELATION</div><canvas id="canvasStereo"></canvas></div>
</div>

<script>
    const FFT_SIZE = 16384;
    let audioCtx, source, analyserMono, analyserL, analyserR, animationId, mediaRecorder;
    let audioBuffer = null;
    let recordedChunks = [];

    const statusEl = document.getElementById('status-bar');
    const inputEl = document.getElementById('audioInput');
    const playBtn = document.getElementById('playBtn');
    const recBtn = document.getElementById('recBtn');

    // カラーパレット
    const palettes = {
        magma: (v) => [v * 255, Math.pow(v, 3) * 180, Math.pow(v, 6) * 255],
        cyber: (v) => [v * 255, Math.pow(v, 2) * 100, 255 - v * 150],
        acid: (v) => [Math.pow(v, 5) * 200, v * 255, 0],
        ice: (v) => [Math.pow(v, 4) * 150, Math.pow(v, 1.5) * 200, v * 255],
        blood: (v) => [v * 255, 0, Math.pow(v, 5) * 100]
    };

    function getRGB(v, preset) {
        const [r, g, b] = palettes[preset](Math.max(0, Math.min(1, v)));
        const flash = v > 0.94 ? (v - 0.94) * 15 * 255 : 0;
        return `rgb(${Math.min(255, r + flash)},${Math.min(255, g + flash)},${Math.min(255, b + flash)})`;
    }

    const modules = {
        Spec: { btn: document.getElementById('btnSpec'), el: document.getElementById('modSpec'), ctx: document.getElementById('canvasSpec').getContext('2d', {alpha:false}) },
        Wave: { btn: document.getElementById('btnWave'), el: document.getElementById('modWave'), ctx: document.getElementById('canvasWave').getContext('2d') },
        Stereo: { btn: document.getElementById('btnStereo'), el: document.getElementById('modStereo'), ctx: document.getElementById('canvasStereo').getContext('2d') }
    };

    Object.keys(modules).forEach(key => {
        modules[key].btn.onclick = () => {
            modules[key].btn.classList.toggle('active');
            modules[key].el.classList.toggle('active');
            resize();
        };
    });

    function resize() {
        Object.keys(modules).forEach(key => {
            const c = modules[key].ctx.canvas;
            c.width = c.clientWidth * window.devicePixelRatio;
            c.height = c.clientHeight * window.devicePixelRatio;
        });
    }
    window.addEventListener('resize', resize);

    // --- 【修正】WAV読み込みロジック ---
    inputEl.onchange = async (e) => {
        const file = e.target.files[0];
        if (!file) return;

        statusEl.innerText = "STATUS: READING BINARY...";
        statusEl.style.color = "#ffaa00";
        playBtn.disabled = recBtn.disabled = true;

        try {
            const arrayBuffer = await file.arrayBuffer();
            const tempCtx = new (window.AudioContext || window.webkitAudioContext)();
            
            statusEl.innerText = "STATUS: DECODING PCM DATA...";
            
            // デコードの第2、第3引数に成功・失敗コールバックを明示的に指定（古いブラウザ対策）
            tempCtx.decodeAudioData(arrayBuffer, (decoded) => {
                audioBuffer = decoded;
                tempCtx.close();
                statusEl.innerText = `STATUS: READY // ${file.name.toUpperCase()}`;
                statusEl.style.color = "#00f2ff";
                playBtn.disabled = recBtn.disabled = false;
                resize();
            }, (err) => {
                throw new Error("DECODE_FAILED");
            });
        } catch (err) {
            statusEl.innerText = "STATUS: ERROR - INVALID FILE OR FORMAT";
            statusEl.style.color = "#ff3366";
        }
    };

    // --- 【修正】再生・録画エンジン ---
    async function start(isRecording = false) {
        if (audioCtx) await audioCtx.close();
        
        audioCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 48000 });
        source = audioCtx.createBufferSource();
        source.buffer = audioBuffer;

        analyserMono = audioCtx.createAnalyser();
        analyserMono.fftSize = FFT_SIZE;

        const splitter = audioCtx.createChannelSplitter(2);
        analyserL = audioCtx.createAnalyser(); 
        analyserR = audioCtx.createAnalyser();
        analyserL.fftSize = analyserR.fftSize = 2048;

        source.connect(analyserMono);
        source.connect(splitter);
        splitter.connect(analyserL, 0); 
        splitter.connect(analyserR, 1);
        
        const streamDest = audioCtx.createMediaStreamDestination();
        source.connect(streamDest);
        source.connect(audioCtx.destination);

        if (isRecording) {
            startMediaRecorder(streamDest.stream);
        }

        source.onended = () => stop();
        source.start(0);
        document.getElementById('stopBtn').disabled = false;
        draw();
    }

    function startMediaRecorder(audioStream) {
        recordedChunks = [];
        // スペクトログラムのキャンバスをメインとしてキャプチャ
        const canvasStream = modules.Spec.ctx.canvas.captureStream(60);
        const combined = new MediaStream([
            canvasStream.getVideoTracks()[0],
            audioStream.getAudioTracks()[0]
        ]);

        // ビットレートを最大化して画質を担保
        const options = { mimeType: 'video/webm;codecs=vp9', videoBitsPerSecond: 40000000 };
        mediaRecorder = new MediaRecorder(combined, options);
        
        mediaRecorder.ondataavailable = (e) => { if (e.data.size > 0) recordedChunks.push(e.data); };
        mediaRecorder.onstop = saveVideo;
        
        mediaRecorder.start();
        recBtn.classList.add('recording');
        statusEl.innerText = "STATUS: RECORDING LIVE...";
    }

    function saveVideo() {
        const blob = new Blob(recordedChunks, { type: 'video/quicktime' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `PRO_RENDER_${Date.now()}.mov`;
        a.click();
        recBtn.classList.remove('recording');
        statusEl.innerText = "STATUS: EXPORT COMPLETE";
    }

    function stop() {
        if (source) try { source.stop(); } catch(e){}
        if (mediaRecorder && mediaRecorder.state !== 'inactive') mediaRecorder.stop();
        if (audioCtx) audioCtx.close();
        cancelAnimationFrame(animationId);
        document.getElementById('stopBtn').disabled = true;
    }

    // --- 描画ループ ---
    function draw() {
        animationId = requestAnimationFrame(draw);
        const preset = document.getElementById('colorSelect').value;
        const speed = parseInt(document.getElementById('speedRange').value);

        // Spectrogram
        if (modules.Spec.el.classList.contains('active')) {
            const ctx = modules.Spec.ctx;
            const data = new Uint8Array(analyserMono.frequencyBinCount);
            analyserMono.getByteFrequencyData(data);
            const w = ctx.canvas.width, h = ctx.canvas.height;
            
            ctx.drawImage(ctx.canvas, speed, 0, w-speed, h, 0, 0, w-speed, h);
            ctx.fillStyle = "#000"; ctx.fillRect(w-speed, 0, speed, h);
            
            const logMin = Math.log10(20), logMax = Math.log10(20000);
            for (let i = 0; i < 800; i++) {
                const p = i/800, f = Math.pow(10, logMin + p*(logMax-logMin));
                const b = Math.floor(f / (audioCtx.sampleRate/FFT_SIZE));
                if (data[b] > 2) {
                    ctx.fillStyle = getRGB(data[b]/255, preset);
                    ctx.fillRect(w-speed, h-(p*h), speed, h/800 + 1);
                }
            }
        }
        
        // Waveform
        if (modules.Wave.el.classList.contains('active')) {
            const ctx = modules.Wave.ctx; const data = new Uint8Array(2048);
            analyserL.getByteTimeDomainData(data);
            ctx.fillStyle = "rgba(0,0,0,0.4)"; ctx.fillRect(0,0,ctx.canvas.width, ctx.canvas.height);
            ctx.beginPath(); ctx.strokeStyle = getRGB(0.8, preset); ctx.lineWidth = 2;
            const step = ctx.canvas.width/data.length;
            for(let i=0; i<data.length; i++) {
                const y = (data[i]/128-1)*ctx.canvas.height*0.4 + ctx.canvas.height/2;
                if(i===0) ctx.moveTo(0, y); else ctx.lineTo(i*step, y);
            }
            ctx.stroke();
        }

        // Stereo
        if (modules.Stereo.el.classList.contains('active')) {
            const ctx = modules.Stereo.ctx; const dL = new Uint8Array(2048), dR = new Uint8Array(2048);
            analyserL.getByteTimeDomainData(dL); analyserR.getByteTimeDomainData(dR);
            ctx.fillStyle = "rgba(0,0,0,0.2)"; ctx.fillRect(0,0,ctx.canvas.width, ctx.canvas.height);
            ctx.beginPath(); ctx.strokeStyle = getRGB(0.9, preset); ctx.lineWidth = 1.2;
            const center = ctx.canvas.width/2;
            for(let i=0; i<dL.length; i+=2) {
                const l = (dL[i]/128-1), r = (dR[i]/128-1);
                const x = (l-r)*center*0.75 + center, y = (l+r)*center*0.75 + center;
                if(i===0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
            }
            ctx.stroke();
        }
    }

    playBtn.onclick = () => start(false);
    recBtn.onclick = () => start(true);
    document.getElementById('stopBtn').onclick = stop;
</script>
</body>
</html>
